name: Deploy to Google Compute Enginename: CI/CD Pipeline - Deploy to AWS



on:on:

  push:  push:

    branches:    branches:

      - main      - github-actions-cicd

  workflow_dispatch:      - main

  pull_request:

concurrency:    branches:

  group: deploy-${{ github.ref_name }}      - github-actions-cicd

  cancel-in-progress: true      - main

  workflow_dispatch:

env:    inputs:

  IMAGE_NAME: url-shortener      environment:

  NODE_VERSION: '18'        description: 'Deployment Environment'

        required: true

jobs:        default: 'production'

  build-and-deploy:        type: choice

    runs-on: ubuntu-latest        options:

    permissions:          - production

      contents: read          - staging

      id-token: write

    env:env:

      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}  AWS_REGION: us-east-1

      REGION: ${{ secrets.GCP_REGION }}  ECR_REPOSITORY: url-shortener-api

      ARTIFACT_REPOSITORY: ${{ secrets.GCP_ARTIFACT_REPO }}  APP_NAME: url-shortener

      IMAGE_TAG: ${{ github.sha }}  APP_PORT: 8001

      GCE_INSTANCE_NAME: ${{ secrets.GCE_INSTANCE_NAME }}

      GCE_ZONE: ${{ secrets.GCE_ZONE }}jobs:

      GCE_SSH_USERNAME: ${{ secrets.GCE_SSH_USERNAME }}  # Job 1: Build and Test

    steps:  build-and-test:

      - name: Checkout    name: Build and Test Application

        uses: actions/checkout@v4    runs-on: ubuntu-latest

    

      - name: Use Node.js ${{ env.NODE_VERSION }}    steps:

        uses: actions/setup-node@v4      - name: Checkout code

        with:        uses: actions/checkout@v4

          node-version: ${{ env.NODE_VERSION }}      

          cache: npm      - name: Set up Node.js

        uses: actions/setup-node@v4

      - name: Install dependencies        with:

        run: npm ci          node-version: '18'

          cache: 'npm'

      - name: Run tests      

        run: npm test      - name: Install dependencies

        run: npm ci

      - name: Authenticate to Google Cloud      

        uses: google-github-actions/auth@v2      - name: Run linting

        with:        run: npm run lint

          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}        continue-on-error: true

          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}      

      - name: Run tests

      - name: Set up Cloud SDK        run: npm test

        uses: google-github-actions/setup-gcloud@v2      

        with:      - name: Upload test results

          project_id: ${{ env.PROJECT_ID }}        if: always()

        uses: actions/upload-artifact@v4

      - name: Configure Docker for Artifact Registry        with:

        run: gcloud auth configure-docker ${REGION}-docker.pkg.dev --quiet          name: test-results

          path: |

      - name: Compose Artifact Registry image URI            coverage/

        run: |            test-results/

          IMAGE_URI="${REGION}-docker.pkg.dev/${PROJECT_ID}/${ARTIFACT_REPOSITORY}/${IMAGE_NAME}:${IMAGE_TAG}"          retention-days: 7

          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV  

  # Job 2: Build and Push Docker Image

      - name: Build Docker image  build-and-push:

        run: docker build -t "${IMAGE_URI}" .    name: Build and Push Docker Image

    runs-on: ubuntu-latest

      - name: Push Docker image    needs: build-and-test

        run: docker push "${IMAGE_URI}"    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    

      - name: Prepare SSH key    outputs:

        run: |      image-tag: ${{ steps.meta.outputs.tags }}

          install -m 700 -d ~/.ssh      image-digest: ${{ steps.build.outputs.digest }}

          printf '%s\n' "${{ secrets.GCE_SSH_PRIVATE_KEY }}" > ~/.ssh/gce-key    

          chmod 600 ~/.ssh/gce-key    steps:

      - name: Checkout code

      - name: Capture instance IP address        uses: actions/checkout@v4

        run: |      

          INSTANCE_IP=$(gcloud compute instances describe "${GCE_INSTANCE_NAME}" --zone "${GCE_ZONE}" --format='get(networkInterfaces[0].accessConfigs[0].natIP)')      - name: Configure AWS credentials

          if [ -z "${INSTANCE_IP}" ]; then        uses: aws-actions/configure-aws-credentials@v4

            echo "Instance ${GCE_INSTANCE_NAME} does not have an external IP." >&2        with:

            exit 1          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}

          fi          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

          echo "INSTANCE_IP=${INSTANCE_IP}" >> $GITHUB_ENV          aws-region: ${{ env.AWS_REGION }}



      - name: Deploy container to Compute Engine      - name: Ensure ECR repository exists

        run: |        run: |

          ssh -i ~/.ssh/gce-key -o StrictHostKeyChecking=no "${GCE_SSH_USERNAME}@${INSTANCE_IP}" <<EOF          set -euo pipefail

          docker pull "${IMAGE_URI}"          echo "Checking ECR repository: $ECR_REPOSITORY"

          docker stop url-shortener || true          if ! aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1; then

          docker rm url-shortener || true            echo "ECR repo '$ECR_REPOSITORY' not found — creating..."

          docker run \            aws ecr create-repository --repository-name "$ECR_REPOSITORY"

            --detach \          else

            --name url-shortener \            echo "ECR repo exists"

            --restart unless-stopped \          fi

            -p 8001:8001 \      

            "${IMAGE_URI}"      - name: Login to Amazon ECR

          EOF        id: login-ecr

        uses: aws-actions/amazon-ecr-login@v2

      - name: Debug ECR context
        run: |
          echo "Registry from login step: ${{ steps.login-ecr.outputs.registry }}"
          aws sts get-caller-identity || true
          aws ecr get-authorization-token --region ${{ env.AWS_REGION }} >/dev/null && echo "ECR auth token retrieved"
      
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            ${{ github.run_number }}
            latest
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false
      
      - name: Image digest
        run: |
          echo "Image pushed with digest: ${{ steps.build.outputs.digest }}"
          echo "Image tags: ${{ steps.meta.outputs.tags }}"
  
  # Job 3: Deploy to Production (Docker on EC2)
  deploy-docker:
    name: Deploy to EC2 with Docker
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/github-actions-cicd' || github.ref == 'refs/heads/main'
    environment:
      name: production
    
    steps:
      - name: Validate deploy secrets
        run: |
          if [ -z "${{ secrets.JENKINS_PUBLIC_IP }}" ]; then
            echo "ERROR: secrets.JENKINS_PUBLIC_IP is missing" >&2
            exit 1
          fi
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "ERROR: secrets.EC2_SSH_PRIVATE_KEY is missing" >&2
            exit 1
          fi
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Resolve EC2 host key
        id: ssh_known_host
        run: |
          ssh-keyscan -H ${{ secrets.JENKINS_PUBLIC_IP }} 2>/dev/null > known_hosts_entry
          {
            echo "entry<<EOF"
            cat known_hosts_entry
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Install SSH Key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          if_key_exists: replace
          known_hosts: ${{ steps.ssh_known_host.outputs.entry }}
      
      - name: Deploy to EC2 via SSH
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.run_number }}
          HOST: ${{ secrets.JENKINS_PUBLIC_IP }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        shell: bash
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@$HOST << 'ENDSSH'
            set -euo pipefail
            set -x
            echo "=== Deploying URL Shortener Application ==="
            
            # Configure AWS CLI
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            export AWS_REGION="${{ env.AWS_REGION }}"
            
            aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
            aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
            aws configure set region $AWS_REGION
            
            # Login to ECR
            echo "Logging into Amazon ECR..."
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
            
            # Check if MongoDB is running
            if ! docker ps -q -f name=url-shortener-mongo | grep -q .; then
              echo "Starting MongoDB container..."
              docker run -d \
                --name url-shortener-mongo \
                --restart unless-stopped \
                -p 27017:27017 \
                mongo:7.0-jammy
              echo "Waiting for MongoDB to start..."
              sleep 10
            else
              echo "MongoDB container already running"
            fi
            
            # Stop and remove old application container
            echo "Stopping old application container..."
            docker stop ${{ env.APP_NAME }} || true
            docker rm ${{ env.APP_NAME }} || true
            
            # Pull latest image
            echo "Pulling latest image..."
            docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.run_number }}
            
            # Run new container
            echo "Starting new application container..."
            docker run -d \
              --name ${{ env.APP_NAME }} \
              --restart unless-stopped \
              --link url-shortener-mongo:mongo \
              -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} \
              -e NODE_ENV=production \
              -e PORT=${{ env.APP_PORT }} \
              -e MONGO_URL=mongodb://mongo:27017/url-shortener \
              ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.run_number }}
            
            # Wait for application to start
            echo "Waiting for application to start..."
            sleep 10
            echo "Current container status:"
            docker ps --filter "name=${{ env.APP_NAME }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
            docker ps --filter "name=url-shortener-mongo" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
            
            # Health check
            echo "Running health check..."
            healthy=false
            for i in {1..5}; do
              if curl -fsS http://localhost:${{ env.APP_PORT }}/health; then
                echo "✅ Application is healthy!"
                healthy=true
                break
              fi
              echo "Waiting for app to be ready... (attempt $i/5)"
              echo "Recent application logs:"
              docker logs --tail 50 ${{ env.APP_NAME }} || true
              echo "Recent MongoDB logs:"
              docker logs --tail 20 url-shortener-mongo || true
              sleep 5
            done
            if [ "$healthy" != "true" ]; then
              echo "❌ Application failed health check after multiple attempts"
              echo "Final container status:"
              docker ps -a || true
              docker logs ${{ env.APP_NAME }} || true
              docker logs url-shortener-mongo || true
              echo "Performing verbose curl for additional context..."
              curl -v http://localhost:${{ env.APP_PORT }}/health || true
              exit 1
            fi
            
            # Cleanup old images
            echo "Cleaning up old Docker images..."
            docker image prune -f
            
            echo "=== Deployment completed successfully! ==="
          ENDSSH
      
      - name: Verify deployment
        run: |
          echo "Application deployed successfully!"
          echo "Access URL: http://${{ secrets.JENKINS_PUBLIC_IP }}:8001"
  
  # Job 4: Deploy to Kubernetes (EKS) - Optional
  deploy-kubernetes:
    name: Deploy to Kubernetes (EKS)
    runs-on: ubuntu-latest
    needs: build-and-push
    if: false  # Disabled by default - set to true to enable EKS deployment
    environment:
      name: production-k8s
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      
      - name: Create Kubernetes secret for DocumentDB
        run: |
          kubectl create secret generic docdb-secret \
            --from-literal=connection-string="${{ secrets.DOCDB_CONNECTION_STRING }}" \
            --from-literal=username="${{ secrets.DOCDB_USERNAME }}" \
            --from-literal=password="${{ secrets.DOCDB_PASSWORD }}" \
            --from-literal=host="${{ secrets.DOCDB_HOST }}" \
            --from-literal=port="${{ secrets.DOCDB_PORT }}" \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy to Kubernetes
        run: |
          # Update image in deployment
          kubectl set image deployment/url-shortener-deployment \
            url-shortener=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.run_number }} \
            --record
          
          # Wait for rollout to complete
          kubectl rollout status deployment/url-shortener-deployment
      
      - name: Get service URL
        run: |
          echo "Service URL:"
          kubectl get service url-shortener-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
  
  # Job 5: Notify on Success/Failure
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-docker]
    if: always()
    
    steps:
      - name: Check deployment status
        run: |
          if [ "${{ needs.deploy-docker.result }}" == "success" ]; then
            echo "✅ Deployment succeeded!"
          else
            echo "❌ Deployment failed!"
            exit 1
          fi
      
      - name: Create deployment summary
        run: |
          echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run Number:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ needs.deploy-docker.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application URL:** http://${{ secrets.JENKINS_PUBLIC_IP }}:8001" >> $GITHUB_STEP_SUMMARY
